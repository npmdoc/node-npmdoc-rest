<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/cujojs/rest#readme"

    >rest (v2.0.0)</a>
</h1>
<h4>RESTful HTTP client library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest">module rest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder">
            function <span class="apidocSignatureSpan">rest.</span>UrlBuilder
            <span class="apidocSignatureSpan">(template, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.chain">
            function <span class="apidocSignatureSpan">rest.</span>chain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.getDefaultClient">
            function <span class="apidocSignatureSpan">rest.</span>getDefaultClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.interceptor">
            function <span class="apidocSignatureSpan">rest.</span>interceptor
            <span class="apidocSignatureSpan">(handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.jsonp">
            function <span class="apidocSignatureSpan">rest.</span>jsonp
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.node">
            function <span class="apidocSignatureSpan">rest.</span>node
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.resetDefaultClient">
            function <span class="apidocSignatureSpan">rest.</span>resetDefaultClient
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.responsePromise">
            function <span class="apidocSignatureSpan">rest.</span>responsePromise
            <span class="apidocSignatureSpan">(obj, callback, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.setDefaultClient">
            function <span class="apidocSignatureSpan">rest.</span>setDefaultClient
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.setPlatformDefaultClient">
            function <span class="apidocSignatureSpan">rest.</span>setPlatformDefaultClient
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.wrap">
            function <span class="apidocSignatureSpan">rest.</span>wrap
            <span class="apidocSignatureSpan">(interceptor, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.xhr">
            function <span class="apidocSignatureSpan">rest.</span>xhr
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>UrlBuilder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>find</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>pubsub</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>rfc5988</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>uriEncoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rest.</span>uriTemplate</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.UrlBuilder">module rest.UrlBuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.UrlBuilder">
            function <span class="apidocSignatureSpan">rest.</span>UrlBuilder
            <span class="apidocSignatureSpan">(template, params)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.UrlBuilder.prototype">module rest.UrlBuilder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.append">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>append
            <span class="apidocSignatureSpan">(template, params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.build">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>build
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.fullyQualify">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>fullyQualify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.isAbsolute">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isAbsolute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.isCrossOrigin">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isCrossOrigin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.isFullyQualified">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isFullyQualified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.parts">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>parts
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.UrlBuilder.prototype.toString">
            function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.base64">module rest.base64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.base64.decode">
            function <span class="apidocSignatureSpan">rest.base64.</span>decode
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.base64.encode">
            function <span class="apidocSignatureSpan">rest.base64.</span>encode
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.find">module rest.find</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.find.findProperties">
            function <span class="apidocSignatureSpan">rest.find.</span>findProperties
            <span class="apidocSignatureSpan">(obj, prop, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.interceptor">module rest.interceptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.interceptor.interceptor">
            function <span class="apidocSignatureSpan">rest.</span>interceptor
            <span class="apidocSignatureSpan">(handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.interceptor.ComplexRequest">
            function <span class="apidocSignatureSpan">rest.interceptor.</span>ComplexRequest
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.jsonp">module rest.jsonp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.jsonp.jsonp">
            function <span class="apidocSignatureSpan">rest.</span>jsonp
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.jsonp.chain">
            function <span class="apidocSignatureSpan">rest.jsonp.</span>chain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.jsonp.wrap">
            function <span class="apidocSignatureSpan">rest.jsonp.</span>wrap
            <span class="apidocSignatureSpan">(interceptor, config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.node">module rest.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.node.node">
            function <span class="apidocSignatureSpan">rest.</span>node
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.node.chain">
            function <span class="apidocSignatureSpan">rest.node.</span>chain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.node.wrap">
            function <span class="apidocSignatureSpan">rest.node.</span>wrap
            <span class="apidocSignatureSpan">(interceptor, config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.pubsub">module rest.pubsub</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.pubsub.publish">
            function <span class="apidocSignatureSpan">rest.pubsub.</span>publish
            <span class="apidocSignatureSpan">(topic)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.pubsub.subscribe">
            function <span class="apidocSignatureSpan">rest.pubsub.</span>subscribe
            <span class="apidocSignatureSpan">(topic, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.registry">module rest.registry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.registry.child">
            function <span class="apidocSignatureSpan">rest.registry.</span>child
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.registry.delegate">
            function <span class="apidocSignatureSpan">rest.registry.</span>delegate
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.registry.lookup">
            function <span class="apidocSignatureSpan">rest.registry.</span>lookup
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.registry.register">
            function <span class="apidocSignatureSpan">rest.registry.</span>register
            <span class="apidocSignatureSpan">(type, converter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.responsePromise">module rest.responsePromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.responsePromise.responsePromise">
            function <span class="apidocSignatureSpan">rest.</span>responsePromise
            <span class="apidocSignatureSpan">(obj, callback, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.responsePromise.make">
            function <span class="apidocSignatureSpan">rest.responsePromise.</span>make
            <span class="apidocSignatureSpan">(promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.responsePromise.promise">
            function <span class="apidocSignatureSpan">rest.responsePromise.</span>promise
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.responsePromise.reject">
            function <span class="apidocSignatureSpan">rest.responsePromise.</span>reject
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.rfc5988">module rest.rfc5988</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.rfc5988.SyntaxError">
            function <span class="apidocSignatureSpan">rest.rfc5988.</span>SyntaxError
            <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.rfc5988.parse">
            function <span class="apidocSignatureSpan">rest.rfc5988.</span>parse
            <span class="apidocSignatureSpan">(input, startRule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.rfc5988.toSource">
            function <span class="apidocSignatureSpan">rest.rfc5988.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.uriEncoder">module rest.uriEncoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.decode">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>decode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encode">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeFragment">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeFragment
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeHost">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeHost
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodePath">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePath
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodePathSegment">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePathSegment
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodePort">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePort
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeQuery">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeQuery
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeScheme">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeScheme
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeURL">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeURL
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriEncoder.encodeUserInfo">
            function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeUserInfo
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.uriTemplate">module rest.uriTemplate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.uriTemplate.expand">
            function <span class="apidocSignatureSpan">rest.uriTemplate.</span>expand
            <span class="apidocSignatureSpan">(template, params)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rest.xhr">module rest.xhr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.xhr.xhr">
            function <span class="apidocSignatureSpan">rest.</span>xhr
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.xhr.chain">
            function <span class="apidocSignatureSpan">rest.xhr.</span>chain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rest.xhr.wrap">
            function <span class="apidocSignatureSpan">rest.xhr.</span>wrap
            <span class="apidocSignatureSpan">(interceptor, config)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest" id="apidoc.module.rest">module rest</a></h1>


    <h2>
        <a href="#apidoc.element.rest.UrlBuilder" id="apidoc.element.rest.UrlBuilder">
        function <span class="apidocSignatureSpan">rest.</span>UrlBuilder
        <span class="apidocSignatureSpan">(template, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlBuilder(template, params) {
	if (!(this instanceof UrlBuilder)) {
		// invoke as a constructor
		return new UrlBuilder(template, params);
	}

	if (template instanceof UrlBuilder) {
		this._template = template.template;
		this._params = mixin({}, this._params, params);
	}
	else {
		this._template = (template || &#x27;&#x27;).toString();
		this._params = params || {};
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.chain" id="apidoc.element.rest.chain">
        function <span class="apidocSignatureSpan">rest.</span>chain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain() {
		if (typeof console !== &#x27;undefined&#x27;) {
			console.log(&#x27;rest.js: client.chain() is deprecated, use client.wrap() instead&#x27;);
		}

		return impl.wrap.apply(this, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
1.1.1
- support for IE 11, Safari 7 and iOS 7 (no code changes required, now actively testing)
- Node specific configuration options via request.mixin. Particularly useful for https clients. Thanks @wwwdata
- basic support for Browserify. Note: Browserify is not yet a tested environment

1.1.0
- bump when.js version to ~3, 2.x is no longer supported
- perfer `client.wrap()` to `client.<span class="apidocCodeKeywordSpan">chain</span>()`, `chain` is now deprecated
- add HTTP specific methods to the promises returned from clients: .entity(), .status(), .headers(), .header(name)
- mime converters may return a promise. Thanks @phillipj
- removed &#x27;rest/util/beget&#x27; favor Object.create

1.0.3
- add moduleType for bower (node and amd). Thanks @briancavalier
- doc polish. Thanks @gogamoga
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.getDefaultClient" id="apidoc.element.rest.getDefaultClient">
        function <span class="apidocSignatureSpan">rest.</span>getDefaultClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultClient() {
	return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.interceptor" id="apidoc.element.rest.interceptor">
        function <span class="apidocSignatureSpan">rest.</span>interceptor
        <span class="apidocSignatureSpan">(handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function interceptor(handlers) {

	var initHandler, requestHandler, successResponseHandler, errorResponseHandler;

	handlers = handlers || {};

	initHandler            = handlers.init    || defaultInitHandler;
	requestHandler         = handlers.request || defaultRequestHandler;
	successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;
	errorResponseHandler   = handlers.error   || function () {
		// Propagate the rejection, with the result of the handler
		return Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments))
			.then(Promise.reject.bind(Promise));
	};

	return function (target, config) {

		if (typeof target === &#x27;object&#x27;) {
			config = target;
		}
		if (typeof target !== &#x27;function&#x27;) {
			target = handlers.client || defaultClient;
		}

		config = initHandler(config || {});

		function interceptedClient(request) {
			var context, meta;
			context = {};
			meta = { &#x27;arguments&#x27;: Array.prototype.slice.call(arguments), client: interceptedClient };
			request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
			request.originator = request.originator || interceptedClient;
			return responsePromise(
				requestHandler.call(context, request, config, meta),
				function (request) {
					var response, abort, next;
					next = target;
					if (request instanceof ComplexRequest) {
						// unpack request
						abort = request.abort;
						next = request.client || next;
						response = request.response;
						// normalize request, must be last
						request = request.request;
					}
					response = response || Promise.resolve(request).then(function (request) {
						return Promise.resolve(next(request)).then(
							function (response) {
								return successResponseHandler.call(context, response, config, meta);
							},
							function (response) {
								return errorResponseHandler.call(context, response, config, meta);
							}
						);
					});
					return abort ? Promise.race([response, abort]) : response;
				},
				function (error) {
					return Promise.reject({ request: request, error: error });
				}
			);
		}

		return client(interceptedClient, target);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.jsonp" id="apidoc.element.rest.jsonp">
        function <span class="apidocSignatureSpan">rest.</span>jsonp
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jsonp(request) {
	return responsePromise.promise(function (resolve, reject) {

		var callbackName, callbackParams, script, firstScript, response;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		request.callback = request.callback || {};
		callbackName = registerCallback(request.callback.prefix || &#x27;jsonp&#x27;, resolve, response, request.callback.name);
		callbackParams = {};
		callbackParams[request.callback.param || &#x27;callback&#x27;] = callbackName;

		request.canceled = false;
		request.cancel = function cancel() {
			request.canceled = true;
			cleanupScriptNode(response);
			reject(response);
		};

		script = document.createElement(&#x27;script&#x27;);
		script.type = &#x27;text/javascript&#x27;;
		script.async = true;
		script.src = response.url = new UrlBuilder(request.path, callbackParams).build();

		function handlePossibleError() {
			if (typeof window[callbackName] === &#x27;function&#x27;) {
				response.error = &#x27;loaderror&#x27;;
				clearProperty(window, callbackName);
				cleanupScriptNode(response);
				reject(response);
			}
		}
		script.onerror = function () {
			handlePossibleError();
		};
		script.onload = script.onreadystatechange = function (e) {
			// script tag load callbacks are completely non-standard
			// handle case where onreadystatechange is fired for an error instead of onerror
			if ((e &#x26;&#x26; (e.type === &#x27;load&#x27; || e.type === &#x27;error&#x27;)) || script.readyState === &#x27;loaded&#x27;) {
				handlePossibleError();
			}
		};

		response.raw = script;
		firstScript = document.getElementsByTagName(&#x27;script&#x27;)[0];
		firstScript.parentNode.insertBefore(script, firstScript);

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.node" id="apidoc.element.rest.node">
        function <span class="apidocSignatureSpan">rest.</span>node
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function node(request) {
	<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:20 */
</span>	return responsePromise.promise(function (resolve, reject) {

		var options, clientRequest, client, url, headers, entity, response;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		url = response.url = request.path || &#x27;&#x27;;
		client = url.match(httpsExp) ? https : http;

		options = mixin({}, request.mixin, parser.parse(url));

		entity = request.entity;
		request.method = request.method || (entity ? &#x27;POST&#x27; : &#x27;GET&#x27;);
		options.method = request.method;
		headers = options.headers = {};
		Object.keys(request.headers || {}).forEach(function (name) {
			headers[normalizeHeaderName(name)] = request.headers[name];
		});
		if (!headers[&#x27;Content-Length&#x27;]) {
			headers[&#x27;Content-Length&#x27;] = entity ? Buffer.byteLength(entity, &#x27;utf8&#x27;) : 0;
		}

		request.canceled = false;
		request.cancel = function cancel() {
			request.canceled = true;
			clientRequest.abort();
		};

		clientRequest = client.request(options, function (clientResponse) {
			// Array of Buffers to collect response chunks
			var buffers = [];

			response.raw = {
				request: clientRequest,
				response: clientResponse
			};
			response.status = {
				code: clientResponse.statusCode
				// node doesn&#x27;t provide access to the status text
			};
			response.headers = {};
			Object.keys(clientResponse.headers).forEach(function (name) {
				response.headers[normalizeHeaderName(name)] = clientResponse.headers[name];
			});

			clientResponse.on(&#x27;data&#x27;, function (data) {
				// Collect the next Buffer chunk
				buffers.push(data);
			});

			clientResponse.on(&#x27;end&#x27;, function () {
				// Create the final response entity
				response.entity = buffers.length &#x3e; 0 ? Buffer.concat(buffers).toString() : &#x27;&#x27;;
				buffers = null;

				resolve(response);
			});
		});

		clientRequest.on(&#x27;error&#x27;, function (e) {
			response.error = e;
			reject(response);
		});

		if (entity) {
			clientRequest.write(entity);
		}
		clientRequest.end();

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.resetDefaultClient" id="apidoc.element.rest.resetDefaultClient">
        function <span class="apidocSignatureSpan">rest.</span>resetDefaultClient
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resetDefaultClient() {
	target = platformDefault;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.responsePromise" id="apidoc.element.rest.responsePromise">
        function <span class="apidocSignatureSpan">rest.</span>responsePromise
        <span class="apidocSignatureSpan">(obj, callback, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function responsePromise(obj, callback, errback) {
	return make(Promise.resolve(obj).then(callback, errback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.setDefaultClient" id="apidoc.element.rest.setDefaultClient">
        function <span class="apidocSignatureSpan">rest.</span>setDefaultClient
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDefaultClient(client) {
	target = client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.setPlatformDefaultClient" id="apidoc.element.rest.setPlatformDefaultClient">
        function <span class="apidocSignatureSpan">rest.</span>setPlatformDefaultClient
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setPlatformDefaultClient(client) {
	if (platformDefault) {
		throw new Error(&#x27;Unable to redefine platformDefaultClient&#x27;);
	}
	target = platformDefault = client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.wrap" id="apidoc.element.rest.wrap">
        function <span class="apidocSignatureSpan">rest.</span>wrap
        <span class="apidocSignatureSpan">(interceptor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(interceptor, config) {
		return interceptor(impl, config);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var rest, mime, client;

rest = require(&#x27;rest&#x27;),
mime = require(&#x27;rest/interceptor/mime&#x27;);

client = rest.<span class="apidocCodeKeywordSpan">wrap</span>(mime);
client({ path: &#x27;/data.json&#x27; }).then(function(response) {
    console.log(&#x27;response: &#x27;, response);
});
```

Before an interceptor can be used, it needs to be configured.  In this case, we will accept the default configuration, and obtain
 a client.  Now when we see the response, the entity will be a JS object instead of a String.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.xhr" id="apidoc.element.rest.xhr">
        function <span class="apidocSignatureSpan">rest.</span>xhr
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xhr(request) {
	return responsePromise.promise(function (resolve, reject) {
		<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:20 */
</span>
		var client, method, url, headers, entity, headerName, response, XHR;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		XHR = request.engine || XMLHttpRequest;
		if (!XHR) {
			reject({ request: request, error: &#x27;xhr-not-available&#x27; });
			return;
		}

		entity = request.entity;
		request.method = request.method || (entity ? &#x27;POST&#x27; : &#x27;GET&#x27;);
		method = request.method;
		url = response.url = request.path || &#x27;&#x27;;

		try {
			client = response.raw = new XHR();

			// mixin extra request properties before and after opening the request as some properties require being set at different phases
 of the request
			safeMixin(client, request.mixin);
			client.open(method, url, true);
			safeMixin(client, request.mixin);

			headers = request.headers;
			for (headerName in headers) {
				/*jshint forin:false */
				if (headerName === &#x27;Content-Type&#x27; &#x26;&#x26; headers[headerName] === &#x27;multipart/form-data&#x27;) {
					// XMLHttpRequest generates its own Content-Type header with the
					// appropriate multipart boundary when sending multipart/form-data.
					continue;
				}

				client.setRequestHeader(headerName, headers[headerName]);
			}

			request.canceled = false;
			request.cancel = function cancel() {
				request.canceled = true;
				client.abort();
				reject(response);
			};

			client.onreadystatechange = function (/* e */) {
				if (request.canceled) { return; }
				if (client.readyState === (XHR.DONE || 4)) {
					response.status = {
						code: client.status,
						text: client.statusText
					};
					response.headers = parseHeaders(client.getAllResponseHeaders());
					response.entity = client.responseText;

					// #125 -- Sometimes IE8-9 uses 1223 instead of 204
					// http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
					if (response.status.code === 1223) {
						response.status.code = 204;
					}

					if (response.status.code &#x3e; 0) {
						// check status code as readystatechange fires before error event
						resolve(response);
					}
					else {
						// give the error callback a chance to fire before resolving
						// requests for file:// URLs do not have a status code
						setTimeout(function () {
							resolve(response);
						}, 0);
					}
				}
			};

			try {
				client.onerror = function (/* e */) {
					response.error = &#x27;loaderror&#x27;;
					reject(response);
				};
			}
			catch (e) {
				// IE 6 will not support error handling
			}

			client.send(entity);
		}
		catch (e) {
			response.error = &#x27;loaderror&#x27;;
			reject(response);
		}

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.UrlBuilder" id="apidoc.module.rest.UrlBuilder">module rest.UrlBuilder</a></h1>


    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.UrlBuilder" id="apidoc.element.rest.UrlBuilder.UrlBuilder">
        function <span class="apidocSignatureSpan">rest.</span>UrlBuilder
        <span class="apidocSignatureSpan">(template, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlBuilder(template, params) {
	if (!(this instanceof UrlBuilder)) {
		// invoke as a constructor
		return new UrlBuilder(template, params);
	}

	if (template instanceof UrlBuilder) {
		this._template = template.template;
		this._params = mixin({}, this._params, params);
	}
	else {
		this._template = (template || &#x27;&#x27;).toString();
		this._params = params || {};
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.UrlBuilder.prototype" id="apidoc.module.rest.UrlBuilder.prototype">module rest.UrlBuilder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.append" id="apidoc.element.rest.UrlBuilder.prototype.append">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>append
        <span class="apidocSignatureSpan">(template, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (template, params) {
		// TODO consider query strings and fragments
		return new UrlBuilder(this._template + template, mixin({}, this._params, params));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	},
	request: function (request, config) {
		var path, params;

		path = request.path || &#x27;&#x27;;
		params = request.params || {};

		request.path = new UrlBuilder(path, config.params).<span class="apidocCodeKeywordSpan">append</span>(&#x27;&#x27;, params).build
();
		delete request.params;

		return request;
	}
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.build" id="apidoc.element.rest.UrlBuilder.prototype.build">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>build
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (params) {
		return buildUrl(this._template, mixin({}, this._params, params));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	/**
	 * True if the URL is absolute
	 *
	 * @return {boolean}
	 */
	isAbsolute: function () {
		return absoluteUrlRE.test(this.<span class="apidocCodeKeywordSpan">build</span>());
	},

	/**
	 * True if the URL is fully qualified
	 *
	 * @return {boolean}
	 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.fullyQualify" id="apidoc.element.rest.UrlBuilder.prototype.fullyQualify">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>fullyQualify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fullyQualify = function () {
		if (typeof location === &#x27;undefined&#x27;) { return this; }
		if (this.isFullyQualified()) { return this; }

		var template = this._template;

		if (startsWith(template, &#x27;//&#x27;)) {
			template = origin.protocol + template;
		}
		else if (startsWith(template, &#x27;/&#x27;)) {
			template = origin.origin + template;
		}
		else if (!this.isAbsolute()) {
			template = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf(&#x27;/&#x27;) + 1);
		}

		if (template.indexOf(&#x27;/&#x27;, 8) === -1) {
			// default the pathname to &#x27;/&#x27;
			template = template + &#x27;/&#x27;;
		}

		return new UrlBuilder(template, this._params);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @see https://developer.mozilla.org/en-US/docs/DOM/window.location
	 *
	 * @returns {Object} a &#x27;window.location&#x27;-like object
	 */
	parts: function () {
		/*jshint maxcomplexity:20 */
		var url, parts;
		url = this.<span class="apidocCodeKeywordSpan">fullyQualify</span>().build().match(urlRE);
		parts = {
			href: url[0],
			protocol: url[1],
			host: url[3] || &#x27;&#x27;,
			hostname: url[4] || &#x27;&#x27;,
			port: url[6],
			pathname: url[7] || &#x27;&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.isAbsolute" id="apidoc.element.rest.UrlBuilder.prototype.isAbsolute">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isAbsolute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAbsolute = function () {
		return absoluteUrlRE.test(this.build());
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		if (startsWith(template, &#x27;//&#x27;)) {
			template = origin.protocol + template;
		}
		else if (startsWith(template, &#x27;/&#x27;)) {
			template = origin.origin + template;
		}
		else if (!this.<span class="apidocCodeKeywordSpan">isAbsolute</span>()) {
			template = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf(&#x27;/&#x27;) + 1);
		}

		if (template.indexOf(&#x27;/&#x27;, 8) === -1) {
			// default the pathname to &#x27;/&#x27;
			template = template + &#x27;/&#x27;;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.isCrossOrigin" id="apidoc.element.rest.UrlBuilder.prototype.isCrossOrigin">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isCrossOrigin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCrossOrigin = function () {
		if (!origin) {
			return true;
		}
		var url = this.parts();
		return url.protocol !== origin.protocol ||
		       url.hostname !== origin.hostname ||
		       url.port !== origin.port;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.isFullyQualified" id="apidoc.element.rest.UrlBuilder.prototype.isFullyQualified">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>isFullyQualified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFullyQualified = function () {
		return fullyQualifiedUrlRE.test(this.build());
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * *Browser only*
	 *
	 * @return {UrlBuilder} the fully qualified URL template
	 */
	fullyQualify: function () {
		if (typeof location === &#x27;undefined&#x27;) { return this; }
		if (this.<span class="apidocCodeKeywordSpan">isFullyQualified</span>()) { return this; }

		var template = this._template;

		if (startsWith(template, &#x27;//&#x27;)) {
			template = origin.protocol + template;
		}
		else if (startsWith(template, &#x27;/&#x27;)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.parts" id="apidoc.element.rest.UrlBuilder.prototype.parts">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>parts
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parts = function () {
		<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:20 */
</span>		var url, parts;
		url = this.fullyQualify().build().match(urlRE);
		parts = {
			href: url[0],
			protocol: url[1],
			host: url[3] || &#x27;&#x27;,
			hostname: url[4] || &#x27;&#x27;,
			port: url[6],
			pathname: url[7] || &#x27;&#x27;,
			search: url[8] || &#x27;&#x27;,
			hash: url[9] || &#x27;&#x27;
		};
		parts.origin = parts.protocol + &#x27;//&#x27; + parts.host;
		parts.port = parts.port || (parts.protocol === &#x27;https:&#x27; ? &#x27;443&#x27; : parts.protocol === &#x27;http:&#x27; ? &#x27;80&#x27; : &#x27;&#x27;);
		return parts;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * @return {boolean}
	 */
	isCrossOrigin: function () {
		if (!origin) {
			return true;
		}
		var url = this.<span class="apidocCodeKeywordSpan">parts</span>();
		return url.protocol !== origin.protocol ||
		       url.hostname !== origin.hostname ||
		       url.port !== origin.port;
	},

	/**
	 * Split a URL into its consituent parts following the naming convention of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.UrlBuilder.prototype.toString" id="apidoc.element.rest.UrlBuilder.prototype.toString">
        function <span class="apidocSignatureSpan">rest.UrlBuilder.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
		return this.build();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	if (template instanceof UrlBuilder) {
		this._template = template.template;
		this._params = mixin({}, this._params, params);
	}
	else {
		this._template = (template || &#x27;&#x27;).<span class="apidocCodeKeywordSpan">toString</span>();
		this._params = params || {};
	}
}

UrlBuilder.prototype = {

	/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.base64" id="apidoc.module.rest.base64">module rest.base64</a></h1>


    <h2>
        <a href="#apidoc.element.rest.base64.decode" id="apidoc.element.rest.base64.decode">
        function <span class="apidocSignatureSpan">rest.base64.</span>decode
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Decode(text) {

	//ignore white space
	text = text.replace(/\s/g, &#x27;&#x27;);

	//first check for any unexpected input
	if (!(/^[a-z0-9\+\/\s]+\={0,2}$/i.test(text)) || text.length % 4 &#x3e; 0) {
		throw new Error(&#x27;Not a base64-encoded string.&#x27;);
	}

	//local variables
	var cur, prev, digitNum,
		i = 0,
		result = [];

	//remove any equals signs
	text = text.replace(/\=/g, &#x27;&#x27;);

	//loop over each character
	while (i &#x3c; text.length) {

		cur = digits.indexOf(text.charAt(i));
		digitNum = i % 4;

		switch (digitNum) {

		//case 0: first digit - do nothing, not enough info to work with

		case 1: //second digit
			result.push(String.fromCharCode(prev &#x3c;&#x3c; 2 | cur &#x3e;&#x3e; 4));
			break;

		case 2: //third digit
			result.push(String.fromCharCode((prev &#x26; 0x0f) &#x3c;&#x3c; 4 | cur &#x3e;&#x3e; 2));
			break;

		case 3: //fourth digit
			result.push(String.fromCharCode((prev &#x26; 3) &#x3c;&#x3c; 6 | cur));
			break;
		}

		prev = cur;
		i += 1;
	}

	//return a string
	return result.join(&#x27;&#x27;);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		if (prefixRE.test(variable)) {
			var prefix = prefixRE.exec(variable);
			variable = prefix[1];
			opts.maxLength = parseInt(prefix[2]);
		}

		variable = uriEncoder.<span class="apidocCodeKeywordSpan">decode</span>(variable);
		value = params[variable];

		if (value === void 0 || value === null) {
			return result;
		}
		if (Array.isArray(value)) {
			result = value.reduce(function (result, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.base64.encode" id="apidoc.element.rest.base64.encode">
        function <span class="apidocSignatureSpan">rest.base64.</span>encode
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Encode(text) {

	if (/([^\u0000-\u00ff])/.test(text)) {
		throw new Error(&#x27;Can\&#x27;t base64 encode non-ASCII characters.&#x27;);
	}

	var i = 0,
		cur, prev, byteNum,
		result = [];

	while (i &#x3c; text.length) {

		cur = text.charCodeAt(i);
		byteNum = i % 3;

		switch (byteNum) {
		case 0: //first byte
			result.push(digits.charAt(cur &#x3e;&#x3e; 2));
			break;

		case 1: //second byte
			result.push(digits.charAt((prev &#x26; 3) &#x3c;&#x3c; 4 | (cur &#x3e;&#x3e; 4)));
			break;

		case 2: //third byte
			result.push(digits.charAt((prev &#x26; 0x0f) &#x3c;&#x3c; 2 | (cur &#x3e;&#x3e; 6)));
			result.push(digits.charAt(cur &#x26; 0x3f));
			break;
		}

		prev = cur;
		i += 1;
	}

	if (byteNum === 0) {
		result.push(digits.charAt((prev &#x26; 3) &#x3c;&#x3c; 4));
		result.push(&#x27;==&#x27;);
	} else if (byteNum === 1) {
		result.push(digits.charAt((prev &#x26; 0x0f) &#x3c;&#x3c; 2));
		result.push(&#x27;=&#x27;);
	}

	return result.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var headers, username, password;

		headers = request.headers || (request.headers = {});
		username = request.username || config.username;
		password = request.password || config.password || &#x27;&#x27;;

		if (username) {
			headers.Authorization = &#x27;Basic &#x27; + base64.<span class="apidocCodeKeywordSpan">encode</span>(username + &#x27;:&#x27
; + password);
		}

		return request;
	}
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.find" id="apidoc.module.rest.find">module rest.find</a></h1>


    <h2>
        <a href="#apidoc.element.rest.find.findProperties" id="apidoc.element.rest.find.findProperties">
        function <span class="apidocSignatureSpan">rest.find.</span>findProperties
        <span class="apidocSignatureSpan">(obj, prop, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findProperties(obj, prop, callback) {
		if (typeof obj !== &#x27;object&#x27; || obj === null) { return; }
		if (prop in obj) {
			callback(obj[prop], obj, prop);
		}
		Object.keys(obj).forEach(function (key) {
			findProperties(obj[key], prop, callback);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		if (response.headers &#x26;&#x26; response.headers.Link) {
			response.links = response.links || {};
			apply(response.links, parseLinkHeaders(response.headers.Link));
		}

		find.<span class="apidocCodeKeywordSpan">findProperties</span>(response.entity, &#x27;links&#x27;, function (obj, host) {
			var target;

			if (Array.isArray(host.links)) {
				if (config.target === &#x27;&#x27;) {
					target = host;
				}
				else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.interceptor" id="apidoc.module.rest.interceptor">module rest.interceptor</a></h1>


    <h2>
        <a href="#apidoc.element.rest.interceptor.interceptor" id="apidoc.element.rest.interceptor.interceptor">
        function <span class="apidocSignatureSpan">rest.</span>interceptor
        <span class="apidocSignatureSpan">(handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function interceptor(handlers) {

	var initHandler, requestHandler, successResponseHandler, errorResponseHandler;

	handlers = handlers || {};

	initHandler            = handlers.init    || defaultInitHandler;
	requestHandler         = handlers.request || defaultRequestHandler;
	successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;
	errorResponseHandler   = handlers.error   || function () {
		// Propagate the rejection, with the result of the handler
		return Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments))
			.then(Promise.reject.bind(Promise));
	};

	return function (target, config) {

		if (typeof target === &#x27;object&#x27;) {
			config = target;
		}
		if (typeof target !== &#x27;function&#x27;) {
			target = handlers.client || defaultClient;
		}

		config = initHandler(config || {});

		function interceptedClient(request) {
			var context, meta;
			context = {};
			meta = { &#x27;arguments&#x27;: Array.prototype.slice.call(arguments), client: interceptedClient };
			request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
			request.originator = request.originator || interceptedClient;
			return responsePromise(
				requestHandler.call(context, request, config, meta),
				function (request) {
					var response, abort, next;
					next = target;
					if (request instanceof ComplexRequest) {
						// unpack request
						abort = request.abort;
						next = request.client || next;
						response = request.response;
						// normalize request, must be last
						request = request.request;
					}
					response = response || Promise.resolve(request).then(function (request) {
						return Promise.resolve(next(request)).then(
							function (response) {
								return successResponseHandler.call(context, response, config, meta);
							},
							function (response) {
								return errorResponseHandler.call(context, response, config, meta);
							}
						);
					});
					return abort ? Promise.race([response, abort]) : response;
				},
				function (error) {
					return Promise.reject({ request: request, error: error });
				}
			);
		}

		return client(interceptedClient, target);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.interceptor.ComplexRequest" id="apidoc.element.rest.interceptor.ComplexRequest">
        function <span class="apidocSignatureSpan">rest.interceptor.</span>ComplexRequest
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ComplexRequest(properties) {
	if (!(this instanceof ComplexRequest)) {
		// in case users forget the &#x27;new&#x27; don&#x27;t mix into the interceptor
		return new ComplexRequest(properties);
	}
	mixin(this, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					request.canceled = false;
				}
			}
			else if (!transient) {
				request.canceled = true;
			}
		}, timeout);
		return new interceptor.<span class="apidocCodeKeywordSpan">ComplexRequest</span>({ request: request, abort: abort });
	},
	response: function (response) {
		if (this.timeout) {
			clearTimeout(this.timeout);
			delete this.timeout;
		}
		return response;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.jsonp" id="apidoc.module.rest.jsonp">module rest.jsonp</a></h1>


    <h2>
        <a href="#apidoc.element.rest.jsonp.jsonp" id="apidoc.element.rest.jsonp.jsonp">
        function <span class="apidocSignatureSpan">rest.</span>jsonp
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jsonp(request) {
	return responsePromise.promise(function (resolve, reject) {

		var callbackName, callbackParams, script, firstScript, response;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		request.callback = request.callback || {};
		callbackName = registerCallback(request.callback.prefix || &#x27;jsonp&#x27;, resolve, response, request.callback.name);
		callbackParams = {};
		callbackParams[request.callback.param || &#x27;callback&#x27;] = callbackName;

		request.canceled = false;
		request.cancel = function cancel() {
			request.canceled = true;
			cleanupScriptNode(response);
			reject(response);
		};

		script = document.createElement(&#x27;script&#x27;);
		script.type = &#x27;text/javascript&#x27;;
		script.async = true;
		script.src = response.url = new UrlBuilder(request.path, callbackParams).build();

		function handlePossibleError() {
			if (typeof window[callbackName] === &#x27;function&#x27;) {
				response.error = &#x27;loaderror&#x27;;
				clearProperty(window, callbackName);
				cleanupScriptNode(response);
				reject(response);
			}
		}
		script.onerror = function () {
			handlePossibleError();
		};
		script.onload = script.onreadystatechange = function (e) {
			// script tag load callbacks are completely non-standard
			// handle case where onreadystatechange is fired for an error instead of onerror
			if ((e &#x26;&#x26; (e.type === &#x27;load&#x27; || e.type === &#x27;error&#x27;)) || script.readyState === &#x27;loaded&#x27;) {
				handlePossibleError();
			}
		};

		response.raw = script;
		firstScript = document.getElementsByTagName(&#x27;script&#x27;)[0];
		firstScript.parentNode.insertBefore(script, firstScript);

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.jsonp.chain" id="apidoc.element.rest.jsonp.chain">
        function <span class="apidocSignatureSpan">rest.jsonp.</span>chain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain() {
		if (typeof console !== &#x27;undefined&#x27;) {
			console.log(&#x27;rest.js: client.chain() is deprecated, use client.wrap() instead&#x27;);
		}

		return impl.wrap.apply(this, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
1.1.1
- support for IE 11, Safari 7 and iOS 7 (no code changes required, now actively testing)
- Node specific configuration options via request.mixin. Particularly useful for https clients. Thanks @wwwdata
- basic support for Browserify. Note: Browserify is not yet a tested environment

1.1.0
- bump when.js version to ~3, 2.x is no longer supported
- perfer `client.wrap()` to `client.<span class="apidocCodeKeywordSpan">chain</span>()`, `chain` is now deprecated
- add HTTP specific methods to the promises returned from clients: .entity(), .status(), .headers(), .header(name)
- mime converters may return a promise. Thanks @phillipj
- removed &#x27;rest/util/beget&#x27; favor Object.create

1.0.3
- add moduleType for bower (node and amd). Thanks @briancavalier
- doc polish. Thanks @gogamoga
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.jsonp.wrap" id="apidoc.element.rest.jsonp.wrap">
        function <span class="apidocSignatureSpan">rest.jsonp.</span>wrap
        <span class="apidocSignatureSpan">(interceptor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(interceptor, config) {
		return interceptor(impl, config);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var rest, mime, client;

rest = require(&#x27;rest&#x27;),
mime = require(&#x27;rest/interceptor/mime&#x27;);

client = rest.<span class="apidocCodeKeywordSpan">wrap</span>(mime);
client({ path: &#x27;/data.json&#x27; }).then(function(response) {
    console.log(&#x27;response: &#x27;, response);
});
```

Before an interceptor can be used, it needs to be configured.  In this case, we will accept the default configuration, and obtain
 a client.  Now when we see the response, the entity will be a JS object instead of a String.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.node" id="apidoc.module.rest.node">module rest.node</a></h1>


    <h2>
        <a href="#apidoc.element.rest.node.node" id="apidoc.element.rest.node.node">
        function <span class="apidocSignatureSpan">rest.</span>node
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function node(request) {
	<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:20 */
</span>	return responsePromise.promise(function (resolve, reject) {

		var options, clientRequest, client, url, headers, entity, response;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		url = response.url = request.path || &#x27;&#x27;;
		client = url.match(httpsExp) ? https : http;

		options = mixin({}, request.mixin, parser.parse(url));

		entity = request.entity;
		request.method = request.method || (entity ? &#x27;POST&#x27; : &#x27;GET&#x27;);
		options.method = request.method;
		headers = options.headers = {};
		Object.keys(request.headers || {}).forEach(function (name) {
			headers[normalizeHeaderName(name)] = request.headers[name];
		});
		if (!headers[&#x27;Content-Length&#x27;]) {
			headers[&#x27;Content-Length&#x27;] = entity ? Buffer.byteLength(entity, &#x27;utf8&#x27;) : 0;
		}

		request.canceled = false;
		request.cancel = function cancel() {
			request.canceled = true;
			clientRequest.abort();
		};

		clientRequest = client.request(options, function (clientResponse) {
			// Array of Buffers to collect response chunks
			var buffers = [];

			response.raw = {
				request: clientRequest,
				response: clientResponse
			};
			response.status = {
				code: clientResponse.statusCode
				// node doesn&#x27;t provide access to the status text
			};
			response.headers = {};
			Object.keys(clientResponse.headers).forEach(function (name) {
				response.headers[normalizeHeaderName(name)] = clientResponse.headers[name];
			});

			clientResponse.on(&#x27;data&#x27;, function (data) {
				// Collect the next Buffer chunk
				buffers.push(data);
			});

			clientResponse.on(&#x27;end&#x27;, function () {
				// Create the final response entity
				response.entity = buffers.length &#x3e; 0 ? Buffer.concat(buffers).toString() : &#x27;&#x27;;
				buffers = null;

				resolve(response);
			});
		});

		clientRequest.on(&#x27;error&#x27;, function (e) {
			response.error = e;
			reject(response);
		});

		if (entity) {
			clientRequest.write(entity);
		}
		clientRequest.end();

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.node.chain" id="apidoc.element.rest.node.chain">
        function <span class="apidocSignatureSpan">rest.node.</span>chain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain() {
		if (typeof console !== &#x27;undefined&#x27;) {
			console.log(&#x27;rest.js: client.chain() is deprecated, use client.wrap() instead&#x27;);
		}

		return impl.wrap.apply(this, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
1.1.1
- support for IE 11, Safari 7 and iOS 7 (no code changes required, now actively testing)
- Node specific configuration options via request.mixin. Particularly useful for https clients. Thanks @wwwdata
- basic support for Browserify. Note: Browserify is not yet a tested environment

1.1.0
- bump when.js version to ~3, 2.x is no longer supported
- perfer `client.wrap()` to `client.<span class="apidocCodeKeywordSpan">chain</span>()`, `chain` is now deprecated
- add HTTP specific methods to the promises returned from clients: .entity(), .status(), .headers(), .header(name)
- mime converters may return a promise. Thanks @phillipj
- removed &#x27;rest/util/beget&#x27; favor Object.create

1.0.3
- add moduleType for bower (node and amd). Thanks @briancavalier
- doc polish. Thanks @gogamoga
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.node.wrap" id="apidoc.element.rest.node.wrap">
        function <span class="apidocSignatureSpan">rest.node.</span>wrap
        <span class="apidocSignatureSpan">(interceptor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(interceptor, config) {
		return interceptor(impl, config);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var rest, mime, client;

rest = require(&#x27;rest&#x27;),
mime = require(&#x27;rest/interceptor/mime&#x27;);

client = rest.<span class="apidocCodeKeywordSpan">wrap</span>(mime);
client({ path: &#x27;/data.json&#x27; }).then(function(response) {
    console.log(&#x27;response: &#x27;, response);
});
```

Before an interceptor can be used, it needs to be configured.  In this case, we will accept the default configuration, and obtain
 a client.  Now when we see the response, the entity will be a JS object instead of a String.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.pubsub" id="apidoc.module.rest.pubsub">module rest.pubsub</a></h1>


    <h2>
        <a href="#apidoc.element.rest.pubsub.publish" id="apidoc.element.rest.pubsub.publish">
        function <span class="apidocSignatureSpan">rest.pubsub.</span>publish
        <span class="apidocSignatureSpan">(topic)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(topic) {
	if (!topics[topic]) { return; }
	topics[topic].apply({}, Array.prototype.slice.call(arguments, 1));
	// auto cleanup
	delete topics[topic];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	m = regex.exec(queryString);
	do {
		params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
		m = regex.exec(queryString);
	} while (m);

	/*jshint camelcase:false */
	pubsub.<span class="apidocCodeKeywordSpan">publish</span>(params.state, params.token_type + &#x27; &#x27; + params.access_token
);
}

function defaultWindowStrategy(url) {
	var w = window.open(url, &#x27;_blank&#x27;, &#x27;width=500,height=400&#x27;);
	return function () {
		w.close();
	};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.pubsub.subscribe" id="apidoc.element.rest.pubsub.subscribe">
        function <span class="apidocSignatureSpan">rest.pubsub.</span>subscribe
        <span class="apidocSignatureSpan">(topic, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribe(topic, callback) {
	topics[topic] = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			&#x27;client_id&#x27;: config.clientId,
			&#x27;scope&#x27;: config.scope,
			&#x27;state&#x27;: state
		});

		dismissWindow = config.windowStrategy(url);

		pubsub.<span class="apidocCodeKeywordSpan">subscribe</span>(state, function (authorization) {
			dismissWindow();
			resolve(authorization);
		});

	});
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.registry" id="apidoc.module.rest.registry">module rest.registry</a></h1>


    <h2>
        <a href="#apidoc.element.rest.registry.child" id="apidoc.element.rest.registry.child">
        function <span class="apidocSignatureSpan">rest.registry.</span>child
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function child() {
		return new Registry(Object.create(mimes));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.registry.delegate" id="apidoc.element.rest.registry.delegate">
        function <span class="apidocSignatureSpan">rest.registry.</span>delegate
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delegate(type) {
		return {
			read: function () {
				var args = arguments;
				return this.lookup(type).then(function (converter) {
					return converter.read.apply(this, args);
				}.bind(this));
			}.bind(this),
			write: function () {
				var args = arguments;
				return this.lookup(type).then(function (converter) {
					return converter.write.apply(this, args);
				}.bind(this));
			}.bind(this)
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// include provided serializers
registry.register(&#x27;application/hal&#x27;, require(&#x27;./type/application/hal&#x27;));
registry.register(&#x27;application/json&#x27;, require(&#x27;./type/application/json&#x27;));
registry.register(&#x27;application/x-www-form-urlencoded&#x27;, require(&#x27;./type/application/x-www-form-urlencoded&#x27;));
registry.register(&#x27;multipart/form-data&#x27;, require(&#x27;./type/multipart/form-data&#x27;));
registry.register(&#x27;text/plain&#x27;, require(&#x27;./type/text/plain&#x27;));

registry.register(&#x27;+json&#x27;, registry.<span class="apidocCodeKeywordSpan">delegate</span>(&#x27;application/json&#x27;));

module.exports = registry;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.registry.lookup" id="apidoc.element.rest.registry.lookup">
        function <span class="apidocSignatureSpan">rest.registry.</span>lookup
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookup(type) {
		var parsed;

		parsed = typeof type === &#x27;string&#x27; ? mime.parse(type) : type;

		if (mimes[parsed.raw]) {
			return mimes[parsed.raw];
		}
		if (mimes[parsed.type + parsed.suffix]) {
			return mimes[parsed.type + parsed.suffix];
		}
		if (mimes[parsed.type]) {
			return mimes[parsed.type];
		}
		if (mimes[parsed.suffix]) {
			return mimes[parsed.suffix];
		}

		return Promise.reject(new Error(&#x27;Unable to locate converter for mime &#x22;&#x27; + parsed.raw + &#x27;&#x22;&#x27;));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		if (!(&#x27;entity&#x27; in request)) {
			return request;
		}

		headers[&#x27;Content-Type&#x27;] = type.raw;

		return config.registry.<span class="apidocCodeKeywordSpan">lookup</span>(type)[&#x27;catch&#x27;](function () {
			// failed to resolve converter
			if (config.permissive) {
				return noopConverter;
			}
			throw &#x27;mime-unknown&#x27;;
		}).then(function (converter) {
			var client = config.client || request.originator,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.registry.register" id="apidoc.element.rest.registry.register">
        function <span class="apidocSignatureSpan">rest.registry.</span>register
        <span class="apidocSignatureSpan">(type, converter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function register(type, converter) {
		mimes[type] = Promise.resolve(converter);
		return mimes[type];
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### Custom MIME Converters: ###

```javascript
var registry = require(&#x27;rest/mime/registry&#x27;);

registry.<span class="apidocCodeKeywordSpan">register</span>(&#x27;application/vnd.com.example&#x27;, {
read: function(str) {
    var obj;
    // do string to object conversions
    return obj;
},
write: function(obj) {
    var str;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.responsePromise" id="apidoc.module.rest.responsePromise">module rest.responsePromise</a></h1>


    <h2>
        <a href="#apidoc.element.rest.responsePromise.responsePromise" id="apidoc.element.rest.responsePromise.responsePromise">
        function <span class="apidocSignatureSpan">rest.</span>responsePromise
        <span class="apidocSignatureSpan">(obj, callback, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function responsePromise(obj, callback, errback) {
	return make(Promise.resolve(obj).then(callback, errback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.responsePromise.make" id="apidoc.element.rest.responsePromise.make">
        function <span class="apidocSignatureSpan">rest.responsePromise.</span>make
        <span class="apidocSignatureSpan">(promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function make(promise) {
	promise.status = status;
	promise.headers = headers;
	promise.header = header;
	promise.entity = entity;
	promise.follow = follow;
	return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.responsePromise.promise" id="apidoc.element.rest.responsePromise.promise">
        function <span class="apidocSignatureSpan">rest.responsePromise.</span>promise
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promise = function (func) {
	return make(new Promise(func));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} [request.callback.name=&#x3c;generated&#x3e;] pins the name of the
 *   callback function, useful for cases where the server doesn&#x27;t allow
 *   custom callback names. Generally not recommended.
 *
 * @returns {Promise&#x3c;Response&#x3e;}
 */
module.exports = client(function jsonp(request) {
	return responsePromise.<span class="apidocCodeKeywordSpan">promise</span>(function (resolve, reject) {

		var callbackName, callbackParams, script, firstScript, response;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.responsePromise.reject" id="apidoc.element.rest.responsePromise.reject">
        function <span class="apidocSignatureSpan">rest.responsePromise.</span>reject
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (val) {
	return make(Promise.reject(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = interceptor({
	init: function (config) {
		config.code = config.code || 400;
		return config;
	},
	response: function (response, config) {
		if (response.status &#x26;&#x26; response.status.code &#x3e;= config.code) {
			return Promise.<span class="apidocCodeKeywordSpan">reject</span>(response);
		}
		return response;
	}
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.rfc5988" id="apidoc.module.rest.rfc5988">module rest.rfc5988</a></h1>


    <h2>
        <a href="#apidoc.element.rest.rfc5988.SyntaxError" id="apidoc.element.rest.rfc5988.SyntaxError">
        function <span class="apidocSignatureSpan">rest.rfc5988.</span>SyntaxError
        <span class="apidocSignatureSpan">(expected, found, offset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SyntaxError = function (expected, found, offset, line, column) {
  function buildMessage(expected, found) {
    var expectedHumanized, foundHumanized;

    switch (expected.length) {
      case 0:
        expectedHumanized = &#x22;end of input&#x22;;
        break;
      case 1:
        expectedHumanized = expected[0];
        break;
      default:
        expectedHumanized = expected.slice(0, expected.length - 1).join(&#x22;, &#x22;)
          + &#x22; or &#x22;
          + expected[expected.length - 1];
    }

    foundHumanized = found ? quote(found) : &#x22;end of input&#x22;;

    return &#x22;Expected &#x22; + expectedHumanized + &#x22; but &#x22; + foundHumanized + &#x22; found.&#x22;;
  }

  this.name = &#x22;SyntaxError&#x22;;
  this.expected = expected;
  this.found = found;
  this.message = buildMessage(expected, found);
  this.offset = offset;
  this.line = line;
  this.column = column;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * handle these states.
 */
if (result === null || pos !== input.length) {
  var offset = Math.max(pos, rightmostFailuresPos);
  var found = offset &#x3c; input.length ? input.charAt(offset) : null;
  var errorPosition = computeErrorPosition();

  throw new this.<span class="apidocCodeKeywordSpan">SyntaxError</span>(
    cleanupExpected(rightmostFailuresExpected),
    found,
    offset,
    errorPosition.line,
    errorPosition.column
  );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.rfc5988.parse" id="apidoc.element.rest.rfc5988.parse">
        function <span class="apidocSignatureSpan">rest.rfc5988.</span>parse
        <span class="apidocSignatureSpan">(input, startRule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, startRule) {
  var parseFunctions = {
    &#x22;start&#x22;: parse_start,
    &#x22;LinkValue&#x22;: parse_LinkValue,
    &#x22;LinkParams&#x22;: parse_LinkParams,
    &#x22;URIReference&#x22;: parse_URIReference,
    &#x22;LinkParam&#x22;: parse_LinkParam,
    &#x22;LinkParamName&#x22;: parse_LinkParamName,
    &#x22;LinkParamValue&#x22;: parse_LinkParamValue,
    &#x22;PToken&#x22;: parse_PToken,
    &#x22;PTokenChar&#x22;: parse_PTokenChar,
    &#x22;OptionalSP&#x22;: parse_OptionalSP,
    &#x22;QuotedString&#x22;: parse_QuotedString,
    &#x22;QuotedStringInternal&#x22;: parse_QuotedStringInternal,
    &#x22;Char&#x22;: parse_Char,
    &#x22;UpAlpha&#x22;: parse_UpAlpha,
    &#x22;LoAlpha&#x22;: parse_LoAlpha,
    &#x22;Alpha&#x22;: parse_Alpha,
    &#x22;Digit&#x22;: parse_Digit,
    &#x22;SP&#x22;: parse_SP,
    &#x22;DQ&#x22;: parse_DQ,
    &#x22;QDText&#x22;: parse_QDText,
    &#x22;QuotedPair&#x22;: parse_QuotedPair
  };

  if (startRule !== undefined) {
    if (parseFunctions[startRule] === undefined) {
      throw new Error(&#x22;Invalid rule name: &#x22; + quote(startRule) + &#x22;.&#x22;);
    }
  } else {
    startRule = &#x22;start&#x22;;
  }

  var pos = 0;
  var reportFailures = 0;
  var rightmostFailuresPos = 0;
  var rightmostFailuresExpected = [];

  function padLeft(input, padding, length) {
    var result = input;

    var padLength = length - input.length;
    for (var i = 0; i &#x3c; padLength; i++) {
      result = padding + result;
    }

    return result;
  }

  function escape(ch) {
    var charCode = ch.charCodeAt(0);
    var escapeChar;
    var length;

    if (charCode &#x3c;= 0xFF) {
      escapeChar = &#x27;x&#x27;;
      length = 2;
    } else {
      escapeChar = &#x27;u&#x27;;
      length = 4;
    }

    return &#x27;\\&#x27; + escapeChar + padLeft(charCode.toString(16).toUpperCase(), &#x27;0&#x27;, length);
  }

  function matchFailed(failure) {
    if (pos &#x3c; rightmostFailuresPos) {
      return;
    }

    if (pos &#x3e; rightmostFailuresPos) {
      rightmostFailuresPos = pos;
      rightmostFailuresExpected = [];
    }

    rightmostFailuresExpected.push(failure);
  }

  function parse_start() {
    var result0, result1, result2, result3, result4;
    var pos0, pos1, pos2, pos3;

    pos0 = pos;
    pos1 = pos;
    result0 = [];
    pos2 = pos;
    pos3 = pos;
    result1 = parse_LinkValue();
    if (result1 !== null) {
      result2 = parse_OptionalSP();
      if (result2 !== null) {
        if (input.charCodeAt(pos) === 44) {
          result3 = &#x22;,&#x22;;
          pos++;
        } else {
          result3 = null;
          if (reportFailures === 0) {
            matchFailed(&#x22;\&#x22;,\&#x22;&#x22;);
          }
        }
        if (result3 !== null) {
          result4 = parse_OptionalSP();
          if (result4 !== null) {
            result1 = [result1, result2, result3, result4];
          } else {
            result1 = null;
            pos = pos3;
          }
        } else {
          result1 = null;
          pos = pos3;
        }
      } else {
        result1 = null;
        pos = pos3;
      }
    } else {
      result1 = null;
      pos = pos3;
    }
    if (result1 !== null) {
      result1 = (function(offset, i) {return i;})(pos2, result1[0]);
    }
    if (result1 === null) {
      pos = pos2;
    }
    while (result1 !== null) {
      result0.push(result1);
      pos2 = pos;
      pos3 = pos;
      result1 = parse_LinkValue();
      if (result1 !== null) {
        result2 = parse_OptionalSP();
        if (result2 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result3 = &#x22;,&#x22;;
            pos++;
          } else {
            result3 = null;
            if (reportFailures === 0) {
              matchFailed(&#x22;\&#x22;,\&#x22;&#x22;);
            }
          }
          if (result3 !== null) {
            result4 = parse_OptionalSP();
            if (result4 !== null) {
              result1 = [result1, result2, result3, result4];
            } else {
              result1 = null;
              pos = pos3;
            }
          } else {
            result1 = null;
            pos = pos3;
          }
        } else {
          result1 = null;
          pos = pos3;
        }
      } else {
        result1 = null;
        pos = pos3;
      }
      if (result1 !== null) {
        result1 = (function(offset, i) {return i;})(pos2, result1[0]);
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			reject(response);
			return;
		}

		url = response.url = request.path || &#x27;&#x27;;
		client = url.match(httpsExp) ? https : http;

		options = mixin({}, request.mixin, parser.<span class="apidocCodeKeywordSpan">parse</span>(url));

		entity = request.entity;
		request.method = request.method || (entity ? &#x27;POST&#x27; : &#x27;GET&#x27;);
		options.method = request.method;
		headers = options.headers = {};
		Object.keys(request.headers || {}).forEach(function (name) {
			headers[normalizeHeaderName(name)] = request.headers[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.rfc5988.toSource" id="apidoc.element.rest.rfc5988.toSource">
        function <span class="apidocSignatureSpan">rest.rfc5988.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () { return this._source; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.uriEncoder" id="apidoc.module.rest.uriEncoder">module rest.uriEncoder</a></h1>


    <h2>
        <a href="#apidoc.element.rest.uriEncoder.decode" id="apidoc.element.rest.uriEncoder.decode">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>decode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode(str) {
	return decodeURIComponent(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		if (prefixRE.test(variable)) {
			var prefix = prefixRE.exec(variable);
			variable = prefix[1];
			opts.maxLength = parseInt(prefix[2]);
		}

		variable = uriEncoder.<span class="apidocCodeKeywordSpan">decode</span>(variable);
		value = params[variable];

		if (value === void 0 || value === null) {
			return result;
		}
		if (Array.isArray(value)) {
			result = value.reduce(function (result, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encode" id="apidoc.element.rest.uriEncoder.encode">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var headers, username, password;

		headers = request.headers || (request.headers = {});
		username = request.username || config.username;
		password = request.password || config.password || &#x27;&#x27;;

		if (username) {
			headers.Authorization = &#x27;Basic &#x27; + base64.<span class="apidocCodeKeywordSpan">encode</span>(username + &#x27;:&#x27
; + password);
		}

		return request;
	}
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeFragment" id="apidoc.element.rest.uriEncoder.encodeFragment">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeFragment
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeFragment = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeHost" id="apidoc.element.rest.uriEncoder.encodeHost">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeHost
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeHost = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodePath" id="apidoc.element.rest.uriEncoder.encodePath">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePath
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodePath = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodePathSegment" id="apidoc.element.rest.uriEncoder.encodePathSegment">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePathSegment
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodePathSegment = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodePort" id="apidoc.element.rest.uriEncoder.encodePort">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodePort
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodePort = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeQuery" id="apidoc.element.rest.uriEncoder.encodeQuery">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeQuery
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeQuery = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeScheme" id="apidoc.element.rest.uriEncoder.encodeScheme">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeScheme
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeScheme = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeURL" id="apidoc.element.rest.uriEncoder.encodeURL">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeURL
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeURL = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.uriEncoder.encodeUserInfo" id="apidoc.element.rest.uriEncoder.encodeUserInfo">
        function <span class="apidocSignatureSpan">rest.uriEncoder.</span>encodeUserInfo
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeUserInfo = function (str) {
		return encode(str, allowed);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.uriTemplate" id="apidoc.module.rest.uriTemplate">module rest.uriTemplate</a></h1>


    <h2>
        <a href="#apidoc.element.rest.uriTemplate.expand" id="apidoc.element.rest.uriTemplate.expand">
        function <span class="apidocSignatureSpan">rest.uriTemplate.</span>expand
        <span class="apidocSignatureSpan">(template, params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expandTemplate(template, params) {
	var start, end, uri;

	uri = &#x27;&#x27;;
	end = 0;
	while (true) {
		start = template.indexOf(&#x27;{&#x27;, end);
		if (start === -1) {
			// no more expressions
			uri += template.slice(end);
			break;
		}
		uri += template.slice(end, start);
		end = template.indexOf(&#x27;}&#x27;, start) + 1;
		uri += expandExpression(template.slice(start + 1, end - 1), params);
	}

	return uri;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	},
	request: function (request, config) {
		var template, params;

		template = request.path || config.template;
		params = mixin({}, request.params, config.params);

		request.path = uriTemplate.<span class="apidocCodeKeywordSpan">expand</span>(template, params);
		delete request.params;

		return request;
	}
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rest.xhr" id="apidoc.module.rest.xhr">module rest.xhr</a></h1>


    <h2>
        <a href="#apidoc.element.rest.xhr.xhr" id="apidoc.element.rest.xhr.xhr">
        function <span class="apidocSignatureSpan">rest.</span>xhr
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xhr(request) {
	return responsePromise.promise(function (resolve, reject) {
		<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:20 */
</span>
		var client, method, url, headers, entity, headerName, response, XHR;

		request = typeof request === &#x27;string&#x27; ? { path: request } : request || {};
		response = { request: request };

		if (request.canceled) {
			response.error = &#x27;precanceled&#x27;;
			reject(response);
			return;
		}

		XHR = request.engine || XMLHttpRequest;
		if (!XHR) {
			reject({ request: request, error: &#x27;xhr-not-available&#x27; });
			return;
		}

		entity = request.entity;
		request.method = request.method || (entity ? &#x27;POST&#x27; : &#x27;GET&#x27;);
		method = request.method;
		url = response.url = request.path || &#x27;&#x27;;

		try {
			client = response.raw = new XHR();

			// mixin extra request properties before and after opening the request as some properties require being set at different phases
 of the request
			safeMixin(client, request.mixin);
			client.open(method, url, true);
			safeMixin(client, request.mixin);

			headers = request.headers;
			for (headerName in headers) {
				/*jshint forin:false */
				if (headerName === &#x27;Content-Type&#x27; &#x26;&#x26; headers[headerName] === &#x27;multipart/form-data&#x27;) {
					// XMLHttpRequest generates its own Content-Type header with the
					// appropriate multipart boundary when sending multipart/form-data.
					continue;
				}

				client.setRequestHeader(headerName, headers[headerName]);
			}

			request.canceled = false;
			request.cancel = function cancel() {
				request.canceled = true;
				client.abort();
				reject(response);
			};

			client.onreadystatechange = function (/* e */) {
				if (request.canceled) { return; }
				if (client.readyState === (XHR.DONE || 4)) {
					response.status = {
						code: client.status,
						text: client.statusText
					};
					response.headers = parseHeaders(client.getAllResponseHeaders());
					response.entity = client.responseText;

					// #125 -- Sometimes IE8-9 uses 1223 instead of 204
					// http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
					if (response.status.code === 1223) {
						response.status.code = 204;
					}

					if (response.status.code &#x3e; 0) {
						// check status code as readystatechange fires before error event
						resolve(response);
					}
					else {
						// give the error callback a chance to fire before resolving
						// requests for file:// URLs do not have a status code
						setTimeout(function () {
							resolve(response);
						}, 0);
					}
				}
			};

			try {
				client.onerror = function (/* e */) {
					response.error = &#x27;loaderror&#x27;;
					reject(response);
				};
			}
			catch (e) {
				// IE 6 will not support error handling
			}

			client.send(entity);
		}
		catch (e) {
			response.error = &#x27;loaderror&#x27;;
			reject(response);
		}

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.xhr.chain" id="apidoc.element.rest.xhr.chain">
        function <span class="apidocSignatureSpan">rest.xhr.</span>chain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain() {
		if (typeof console !== &#x27;undefined&#x27;) {
			console.log(&#x27;rest.js: client.chain() is deprecated, use client.wrap() instead&#x27;);
		}

		return impl.wrap.apply(this, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
1.1.1
- support for IE 11, Safari 7 and iOS 7 (no code changes required, now actively testing)
- Node specific configuration options via request.mixin. Particularly useful for https clients. Thanks @wwwdata
- basic support for Browserify. Note: Browserify is not yet a tested environment

1.1.0
- bump when.js version to ~3, 2.x is no longer supported
- perfer `client.wrap()` to `client.<span class="apidocCodeKeywordSpan">chain</span>()`, `chain` is now deprecated
- add HTTP specific methods to the promises returned from clients: .entity(), .status(), .headers(), .header(name)
- mime converters may return a promise. Thanks @phillipj
- removed &#x27;rest/util/beget&#x27; favor Object.create

1.0.3
- add moduleType for bower (node and amd). Thanks @briancavalier
- doc polish. Thanks @gogamoga
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rest.xhr.wrap" id="apidoc.element.rest.xhr.wrap">
        function <span class="apidocSignatureSpan">rest.xhr.</span>wrap
        <span class="apidocSignatureSpan">(interceptor, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(interceptor, config) {
		return interceptor(impl, config);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var rest, mime, client;

rest = require(&#x27;rest&#x27;),
mime = require(&#x27;rest/interceptor/mime&#x27;);

client = rest.<span class="apidocCodeKeywordSpan">wrap</span>(mime);
client({ path: &#x27;/data.json&#x27; }).then(function(response) {
    console.log(&#x27;response: &#x27;, response);
});
```

Before an interceptor can be used, it needs to be configured.  In this case, we will accept the default configuration, and obtain
 a client.  Now when we see the response, the entity will be a JS object instead of a String.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
